# Documentation for `lab/02-lab-processos` - `inspersh`: A Simple Shell

This directory contains `inspersh.c`, the source code for a simple custom shell called "inspersh". This shell implements several basic functionalities found in typical command-line interpreters. The `README.md` in this directory contains a student's reflection on their work, including a YouTube link for a demo and notes about development.

## `inspersh.c` Program Explained

`inspersh` is designed to mimic some core behaviors of a Unix shell. It reads user commands, parses them, and executes them. The implementation is divided into phases, as suggested by comments in the code and the original `README.md`.

### Core Functionality

*   **Command Loop**: The `main` function runs an infinite loop that:
    1.  Prints a prompt.
    2.  Reads a line of input from the user.
    3.  Parses the input line into tokens (command and arguments).
    4.  Executes the command.
    5.  Saves the command to history (unless it's a history command itself or `exit`).
*   **Signal Handling**: `signal(SIGINT, handle_sigint)` sets up a handler for `SIGINT` (Ctrl+C).
*   **History File**: The shell takes the name of a history file as a command-line argument (e.g., `./inspersh historico.txt`). Commands are appended to this file.

### Phase 1: Basic Shell Operations

This phase covers fundamental shell interactions and built-in commands.

1.  **`print_prompt()`**:
    *   **Purpose**: Displays the shell prompt.
    *   **Format**: `(pid=<pid>)<path>$ `
        *   `<pid>`: The Process ID of the `inspersh` shell itself (obtained via `getpid()`).
        *   `<path>`: The current absolute working directory (obtained via `getcwd()`).
    *   `fflush(stdout)` is used to ensure the prompt is displayed immediately.

2.  **`parse_input(char *line, char **tokens)`**:
    *   **Purpose**: Tokenizes the input line into a command and its arguments.
    *   **Mechanism**: Uses `strtok()` with space (" ") and newline ("
") as delimiters.
    *   **Storage**: Stores pointers to tokens in the `tokens` array. The array is `NULL`-terminated.
    *   **Returns**: The number of tokens found.

3.  **`handle_cd(char **tokens, int token_count)`**:
    *   **Purpose**: Implements the `cd` (change directory) built-in command.
    *   **Behavior**:
        *   If an argument is provided (e.g., `cd /some/path`), it attempts to change to that directory using `chdir()`.
        *   If no argument is provided (`cd`), it changes to the initial directory where `inspersh` was started (stored in `initial_dir`).
        *   Prints an error message if `chdir()` fails (e.g., directory not found).

4.  **`handle_ls()`**:
    *   **Purpose**: Implements a custom `ls` (list directory contents) built-in command. This is *not* an execution of the system's `/bin/ls`.
    *   **Behavior**:
        *   Uses `opendir()`, `readdir()`, and `closedir()` to iterate through entries in the current directory (`.`).
        *   Skips hidden files (names starting with `.`).
        *   For each entry, uses `stat()` to get file information.
        *   **Output Format**: `type - size - name`
            *   `type`: 'd' for directory, 'a' for other file types (presumably "arquivo" or "all").
            *   `size`: File size in bytes for regular files (obtained from `st_size`). For directories, it prints "-".
            *   `name`: The name of the directory entry.

### Phase 2: External Commands and Signal Handling

This phase deals with running external programs and managing signals.

1.  **`handle_sigint(int sig)`**:
    *   **Purpose**: Handles the `SIGINT` signal (typically generated by Ctrl+C).
    *   **Behavior**:
        *   If a child process is currently running (`child_pid > 0`), it sends `SIGINT` to that child process using `kill(child_pid, SIGINT)`.
        *   Prints a message indicating that the external command was terminated.
        *   If no child process is running, the signal is effectively ignored by the shell's main loop (though `SIGINT` would still interrupt `read()` if it's blocked, which is handled).

2.  **`handle_external(char **tokens)`**:
    *   **Purpose**: Executes commands that are not built-in (e.g., `/bin/echo`, `python`, etc.).
    *   **Mechanism**:
        *   Uses `fork()` to create a child process.
        *   **Child Process (`child_pid == 0`)**:
            *   Calls `execvp(tokens[0], tokens)` to replace its image with the command to be executed. `execvp` searches for the command in `PATH` if it doesn't contain a slash.
            *   If `execvp` fails (e.g., command not found), the child process will print an error and exit.
        *   **Parent Process (`child_pid > 0`)**:
            *   Stores the command name in `current_cmd` and the child's PID in `child_pid` (for the signal handler).
            *   Calls `waitpid(child_pid, &status, 0)` to wait for the child process to terminate.
            *   After the child terminates, it prints a success message if the child exited normally with status 0.
            *   Resets `child_pid` and `current_cmd`.

### Phase 3: History

This phase implements a command history feature, allowing users to recall and re-execute previous commands. The history is stored in a file specified as a command-line argument to `inspersh`.

1.  **`history_fd`**: A global file descriptor for the history file, opened in `main`.
    *   `open(argv[1], O_CREAT | O_RDWR | O_APPEND, 0644)`: Opens/creates the history file for read-write, with new commands appended.

2.  **`save_to_history(char *line)`**:
    *   **Purpose**: Saves the executed command line to the history file.
    *   **Behavior**: Writes the command string followed by a newline to `history_fd`.
    *   Called from `main` for every command unless it's a history command itself or `exit`.

3.  **`execute_history(char **tokens, char *original_line)`**:
    *   **Purpose**: Handles history-related commands: `!`, `!#`, `!<prefix>`.
    *   **Mechanism**:
        *   Reads all lines from the history file into an array `history[MAX_HISTORY][MAX_LINE]`. `lseek(history_fd, 0, SEEK_SET)` is used to rewind the file pointer before reading.
        *   **`!`**: Lists all commands in history with their numbers.
        *   **`!#`** (e.g., `!5`): Executes the command at history index `#`.
            *   `atoi(&tokens[0][1])` converts the number part to an integer.
        *   **`!<prefix>`** (e.g., `!ls`): Executes the most recent command in history that starts with `<prefix>`.
            *   `strncmp()` is used for prefix matching.
        *   If a command is found for re-execution:
            *   It's printed to the console.
            *   A copy of the command string is tokenized using `parse_input`.
            *   The re-executed command is then dispatched (e.g., to `handle_cd`, `handle_ls`, or `handle_external`).
            *   The re-executed command itself is then saved to history using `save_to_history()`.
        *   Error messages are printed if history is empty or a command isn't found.

### Phase 4 (Not Implemented)
The code contains a comment: `// mt dificil luba :(` (meaning "too hard, Luba"). This suggests that Phase 4, which might have included features like pipes (`|`) or I/O redirection (`<`, `>`), was not completed.

### `main()` Function Summary
*   Initializes `initial_dir`.
*   Sets up the `SIGINT` handler.
*   Opens the history file specified by `argv[1]`.
*   Enters the main command loop:
    *   `print_prompt()`.
    *   `read()` input. (Note: `read(STDIN_FILENO, ...)` is used directly instead of `fgets` or `getline`).
    *   Processes the input line (removes newline, copies for history).
    *   `parse_input()`.
    *   If not `exit` and not a history recall command, `save_to_history()`.
    *   Dispatches based on the command: `!`, `exit`, `cd`, `ls`, or `handle_external`.
*   Closes `history_fd` before exiting.

## Compilation and Usage

### Compilation
The `README.md` and comments suggest the following compilation command:
```bash
gcc inspersh.c -Wall -Wno-unused-result -g -Og -o inspersh
```
*   `-Wall`: Enable most warnings.
*   `-Wno-unused-result`: Suppress warnings about ignoring the return value of functions like `write` or `read` (though checking these is good practice).
*   `-g`: Include debug information.
*   `-Og`: Optimize for debugging.

### Running `inspersh`
The shell requires a history file name as a command-line argument:
```bash
./inspersh historico.txt
```
If `historico.txt` doesn't exist, it will be created.

### Example Commands within `inspersh`
```
(pid=1234)/home/user$ ls
d - - - Desktop
a - 1024 - notes.txt
(pid=1234)/home/user$ cd Desktop
(pid=1234)/home/user/Desktop$ echo "Hello World"
(pid=1235):comando externo [echo] executado com sucesso.
(pid=1234)/home/user/Desktop$ !
0       ls
1       cd Desktop
2       echo "Hello World"
(pid=1234)/home/user/Desktop$ !0
ls
d - - - SomeFolder
(pid=1234)/home/user/Desktop$ exit
```

This shell provides a good hands-on example of process management, basic I/O, signal handling, and string manipulation in C, forming the foundation of how more complex command-line interpreters operate.
```
